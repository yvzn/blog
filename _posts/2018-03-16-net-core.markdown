---
title: Une app .NET Core sur Docker et Kubernetes
date: 2018-03-16 00:00:00 Z
layout: post
author: Yvan Razafindramanana
---

.NET Core est un framework open source permettant de cr√©er
des applications web avec le langage C#. Dans cet
article je pr√©sente les √©tapes de la mise
en place d'une API REST avec .NET Core.

<!--more-->

Article initialement post√© sur le blog [SofteamOuest](https://softeamouest.github.io/2018/03/16/net-core.html).

Quelques technos utilis√©es:

* [.NET Core](https://www.microsoft.com/net/learn/in-browser-tutorial/1) (ASP.NET MVC)
* Docker / Kubernetes / Jenkins pipeline
* Swashbuckle pour l'int√©gration Swagger
* Moq pour les tests unitaires

# L'application

Il s'agit d'une API REST de gestion d'une liste
de widgets. Chaque widget a un nom et une
URL. Le code source du projet est disponible sous 
[Github](https://github.com/SofteamOuest/wallboard-back).

L'API impl√©mente un CRUD. Pour la mise en place, je me
suis bas√© sur 
[ce tutoriel](https://docs.microsoft.com/en-us/aspnet/core/tutorials/web-api-vsc)
disponible dans la documentation
officielle de Microsoft.

Les ressources REST sont cr√©es √† l'aide de classes
contr√¥leur, d√©cor√©es avec l'attribut `[Route]`. Les verbes
REST sont impl√©ment√©s √† l'aide des attributs `[HttpGet]`, `[HttpPut]`,
etc.

```c#
[Route("api/[controller]")]
public class WidgetsController : Controller
...
[HttpGet]
public IEnumerable<Widget> GetAll()
...
```
[source de cet exemple](https://github.com/SofteamOuest/wallboard-back/blob/master/WallboardBack/Controllers/WidgetsController.cs)

Une base de donn√©es en m√©moire est acc√©d√©e √† l'aide d'un 
database context EntityFramework.

L'application est "bootstrap√©e" dans `Startup.cs`, qui 
contient la configuration des classes, configure ASP.NET MVC
et active l'injection de d√©pendances.

## Environnement de d√©veloppement

J'ai pr√©f√©r√© utiliser la commande `dotnet` (`dotnet new`,
`dotnet add`, etc.) fournie avec le SDK, pour initialiser
le projet en ligne de commande.
On peut √©galement le faire via Visual Studio, mais je trouve
qu'on comprend mieux ce qui se passe avec `dotnet`.
Les tutoriels indiqu√©s pr√©sentent les deux approches.

Pour l'environnement de d√©veloppement, il est 
possible d'utiliser (en th√©orie)
un simple √©diteur ou (mieux) VSCode: on trouve 
pas mal d'aides et de plugins.
A la longue, un IDE plus int√©gr√© se justifie plus facilement,
pour les outils de refactoring et de g√©n√©ration de code
automatique qu'il fournit.

J'ai donc install√© Visual Studio Community Edition
(gratuit, sous conditions) Le top c'est le Rider de
JetBrains, si vous arrivez √† n√©gocier une licence ü§ë.

## Activation de CORS

Pour utiliser l'API avec une autre application, j'ai eu besoin
d'activer CORS et `Access-Control-Allow-Origin`. Ca se met
en place en quelques lignes avec .NET MVC, je me suis bas√© sur
[ce tutoriel](https://docs.microsoft.com/en-us/aspnet/core/security/cors).

## Activation de Swagger

Pour simplifier l'utilisation de l'API lors du d√©veloppement,
j'ai ajout√© Swagger et son interface graphique SwaggerUI.

L'explication pour la mise en place de Swagger
[dans ce tutoriel](https://docs.microsoft.com/en-us/aspnet/core/tutorials/web-api-help-pages-using-swagger). 
En l'occurence j'ai utilis√© la librairie Swashbuckle comme d√©crit
[ici](https://docs.microsoft.com/en-us/aspnet/core/tutorials/getting-started-with-swashbuckle?tabs=netcore-cli%2Cvisual-studio-xml).

L√† aussi c'est assez rapide.
Par contre j'ai rencontr√© un souci pour
servir Swagger dans un 
sous-r√©pertoire de mon domaine, par exemple sous `exemple.com/back/swagger.json`.
Je n'ai pu configurer Swashbuckle que 
directement √† la racine `exemple.com/swagger.json`. Il faudrait
creuser le souci ü§î.

# Dockerisation

L'id√©e est de conteneuriser l'application avec Docker
pour la d√©ployer dans le cluster Kubernetes de l'usine logicielle
de la communaut√© SofteamOuest.

## La th√©orie

Il existe plusieurs images Docker officielles 
permettant de conteneuriser et
d'ex√©cuter une application .NET Core.

L'image `dotnet:sdk` permet de construire les binaires de
l'application (.dll) √† partir du code source.
Elle est assez lourde (plus d'un gigaoctet) donc patience.

Il est g√©n√©ralement pr√©f√©rable d'utiliser l'image
`dotnet:runtime`, plus l√©g√®re, pour l'ex√©cution.

Il est √©videmment possible tout faire
 avec l'image `dotnet:sdk`, mais le conteneur g√©n√©r√© 
pour l'application
est alors tr√®s volumineux et ce n'est pas recommand√©
en production.

## En pratique 

La construction de l'image de l'application n√©cessite donc
d'utiliser cons√©cutivement deux images dans le Dockerfile :
`dotnet:sdk` pour compiler le binaire puis `dotnet:runtime` pour
l'image finale.

```docker
FROM microsoft/dotnet:sdk AS build-env
RUN dotnet publish -c Release -o out
...
FROM microsoft/aspnetcore:2.0
COPY --from=build-env /app/out .
...
```

C'est ce qui est d'ailleurs conseill√© dans
[les tutoriels Docker](https://docs.docker.com/engine/examples/dotnetcore/#create-a-dockerfile-for-an-aspnet-core-application) 
et [Microsoft](https://docs.microsoft.com/en-us/dotnet/core/docker/building-net-docker-images)

Malheureusement cette solution _multistage build_
n√©cessite une version de Docker
assez r√©cente, non possible sur notre plateforme.
Nous allons donc utiliser les deux images mais s√©par√©ment,
gr√¢ce aux facilit√©s propos√©es par notre Jenkins pipeline...

# D√©ploiement sur le cluster

L'image `dotnet:sdk` est utilis√©e localement sur la plateforme
d'int√©gration pour construire les binaires.
Le [Dockerfile](https://github.com/SofteamOuest/wallboard-back/blob/master/Dockerfile)
utilise alors uniquement l'image `dotnet:runtime` et
r√©cup√®re les binaires g√©n√©r√©s pr√©c√©demment dans l'environnement
de travail de Jenkins.

```groovy
...
containerTemplate(name: 'dotnet', image: 'microsoft/dotnet'),
...
container('dotnet') {
    sh 'dotnet publish -c Release -o out'
}
...
container('docker') {
    docker build .
}
...
```
[source de cet exemple](https://github.com/SofteamOuest/wallboard-back/blob/master/Jenkinsfile)

Une fois l'image Docker cr√©ee, elle est publi√©e sur le Nexus.
Le d√©ploiement sur le clusteur peut alors √™tre r√©alis√©
√† l'aide d'un job de d√©ploiement Kubernetes (comme expliqu√©
[ici](https://softeamouest.github.io/2018/01/14/deploiement-kubernetes.html)
et [ici](https://softeamouest.github.io/2018/02/09/new-job.html))

# Conclusion

J'ai trouv√© la cr√©ation de cette API REST √† l'aide de .NET Core
assez rapide et efficace. J'ai notamment appr√©ci√© la facilit√©
avec laquelle on peut ajouter des outils de s√©curisation ou
d'aide au d√©veloppement, comme CORS ou Swagger, 
avec un minimum de code.

C'est l'avantage d'arriver apr√®s tout le monde üòÑ : proposer un
framework moderne avec des technos √©prouv√©es,
adaptable rapidement avec une configuration minimale.

Le framework
est suffisament bien document√©, sauf lorsqu'on veut faire des
choses un peu plus inhabituelles, et l√† il faut vraiment chercher...

Prochainement, je souhaite remplacer la base m√©moire
par MongoDB et ajouter plus de tests avec Specflow.
